/*
This file is generated by https://github.com/nok/sklearn-porter/

Estimator:
    GaussianNB
    https://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html

Environment:
    scikit-learn v0.22.1
    sklearn-porter v1.0.0

Usage:
    1. Execute a prediction:
        $ node GaussianNB.js feature_1 ... feature_4
*/
var GaussianNB = function(priors, sigmas, thetas) {

    this.priors = priors;
    this.sigmas = sigmas;
    this.thetas = thetas;

    var _findMax = function(nums) {
        var i = 0, l = nums.length, idx = 0;
        for (; i < l; i++) {
            idx = nums[i] > nums[idx] ? i : idx;
        }
        return idx;
    };

    var _logSumExp = function(nums) {
        var i, l = nums.length;
        var max = Math.max(...nums);
        var sum = 0.;
        for (i = 0; i < l; i++) {
            sum += Math.exp(nums[i] - max);
        }
        return max + Math.log(sum);
    };

    var _compute = function(features, priors, sigmas, thetas) {
        var i, il, j, jl, sum, nij,
            likelihoods = new Array(sigmas.length);
        for (i = 0, il = sigmas.length; i < il; i++) {
            sum = 0.;
            for (j = 0, jl = sigmas[0].length; j < jl; j++) {
                sum += Math.log(2. * Math.PI * sigmas[i][j]);
            }
            nij = -0.5 * sum;
            sum = 0.;
            for (j = 0, jl = sigmas[0].length; j < jl; j++) {
                sum += Math.pow(features[j] - thetas[i][j], 2.) / sigmas[i][j];
            }
            nij -= 0.5 * sum;
            likelihoods[i] = Math.log(priors[i]) + nij;
        }
        return likelihoods;
    };

    this.predict = function(features) {
        return _findMax(_compute(features, this.priors, this.sigmas, this.thetas));
    };

    this.predictProba = function(features) {
        var jll = _compute(features, this.priors, this.sigmas, this.thetas);
        var sum = _logSumExp(jll);
        for (i = 0; i < jll.length; i++) {
            jll[i] = Math.exp(jll[i] - sum);
        }
        return jll;
    };

};

var main = function () {
    if (typeof process !== 'undefined' && typeof process.argv !== 'undefined') {
        if (process.argv.length - 2 !== 4) {
            var IllegalArgumentException = function(message) {
                this.message = message;
                this.name = "IllegalArgumentException";
            }
            throw new IllegalArgumentException("You have to pass 4 features.");
        }
    }

    // Features:
    var features = process.argv.slice(2);
    for (var i = 0; i < features.length; i++) {
        features[i] = parseFloat(features[i]);
    }

    // Model data:
    var priors = [0.6944348427238161, 0.30539232630487384, 0.00017283097131005876];
    var sigmas = [[53.45096418352631, 2.3883995772598237, 198001.55202860263, 47083.065200662255], [488.10606435209627, 3.106126039211068, 228000.29304947908, 45103.14653293298], [0.00020791311826587965, 0.00020791311826587965, 0.00020791311826587965, 0.00020791311826587965]];
    var thetas = [[3.4843777999004515, 9.102538576406172, 682.1209556993529, 398.2772523643604], [34.111986417657064, 9.649688737973968, 738.4402942840974, 351.4895302773062], [35.05, 7.0, 1503.0, 203.0]];

    // Estimator:
    var clf = new GaussianNB(priors, sigmas, thetas);

    // Get class prediction:
    var prediction = clf.predict(features);
    console.log("Predicted class: #" + prediction);

    // Get class probabilities:
    var probabilities = clf.predictProba(features);
    for (var i = 0; i < probabilities.length; i++) {
        console.log("Probability of class #" + i + " : " + probabilities[i]);
    }
}

if (require.main === module) {
    main();
}
